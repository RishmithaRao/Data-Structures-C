{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1033{\fonttbl{\f0\fnil\fcharset0 Berlin Sans FB Demi;}{\f1\fnil\fcharset0 Arial Rounded MT Bold;}{\f2\fnil\fcharset0 Calibri;}{\f3\fnil\fcharset0 Bahnschrift SemiBold SemiConden;}{\f4\fnil\fcharset0 Bahnschrift SemiBold Condensed;}}
{\*\generator Riched20 10.0.22000}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\b\f0\fs28\lang9 1. Arrays\par
\f1 Definition\b0\f2 : A collection of elements stored in contiguous memory locations.\par
\f1 Operations:\par
\b\f3 Access: \b0\f2 arr[index] (O(1))\b\f0\par
\f4 Insertion: \b0\f2 Shift elements (O(n))\par
\b\f3 Deletion: \b0\f2 Shift elements (O(n))\par
\b\f0 Time Complexity:\par
\f3 Access: \b0\f2 O(1)\par
\b\f3 Insertion/Deletion: \b0\f2 O(n)\par
\b\f3 Space Complexity: \b0\f2 O(n)\par
\b\f0 Sample Code:\par
\b0\f2 int arr[10]; // Declaration\par
arr[0] = 1; // Insertion\par
int x = arr[0]; // Access\par
\b\f3 Applications: \b0\f2 Store fixed-size data, buffer storage.\par
\b\f3 Advantages: \b0\f2 Fast access by index.\par
\b\f3 Disadvantages: \b0\f2 Fixed size, expensive insertions and deletions.\par
\b\f0 2.Linked Lists\b0\f2\par
\b\f0 Definition: \b0\f2 A collection of nodes where each node contains data and a pointer to the next node.\par
\b\f0 Operations:\par
\f3 Insertion: \b0\f2 Add new node (O(1) front)\par
\b\f3 Deletion: \b0\f2 Remove node (O(1) front)\par
\b\f3 Traversal: \b0\f2 Visit all nodes (O(n))\par
\b\f0 Time Complexity:\par
\f3 Insertion/Deletion: \b0\f2 O(1) (front)\par
\b\f3 Traversal: \b0\f2 O(n)\par
\b\f3 Space Complexity: \b0\f2 O(n)\par
\b\f0 Sample code:\par
\b0\f2 struct Node \{\par
    int data;\par
    struct Node* next;\par
\};\par
struct Node* head = NULL;\par
struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\par
newNode->data = 1;\par
newNode->next = head;\par
head = newNode; // Insertion at the front\par
\b\f3 Applications: \b0\f2 Dynamic memory allocation, stack and queue implementation.\par
\b\f3 Advantages: \b0\f2 Dynamic size, easy insertion/deletion.\par
\b\f3 Disadvantages: \b0\f2 Extra memory for pointers, linear access time.\par
\b\f0 3.Stacks\b0\f2\par
\b\f0 Definition: \b0\f2 A collection of elements with Last In First Out (LIFO) access.\par
\b\f0 Operations:\b0\f2\par
\b\f3 Push: \b0\f2 Add element to top (O(1))\par
\b\f3 Pop: \b0\f2 Remove element from top (O(1))\par
\b\f3 Peek: \b0\f2 View top element (O(1))\par
\b\f0 Time Complexity: \b0\f2 O(1) for all operations.\par
\b\f0 Space Complexity: \b0\f2 O(n)\par
\b\f0 Sample Code:\b0\f2\par
#define MAX 100\par
int stack[MAX], top = -1;\par
void push(int x) \{ stack[++top] = x; \}\par
int pop() \{ return stack[top--]; \}\par
int peek() \{ return stack[top]; \}\par
\b\f3 Applications: \b0\f2 Function call management, expression evaluation.\par
\b\f3 Advantages: \b0\f2 Simple implementation, efficient access to the top element.\par
\b\f3 Disadvantages: \b0\f2 Limited access to only the top element.\par
\b\f0 4.Queues\b0\f2\par
\b\f0 Definition: \b0\f2 A collection of elements with First In First Out (FIFO) access.\par
\b\f0 Operations:\par
\f3 Enqueue: \b0\f2 Add element to end (O(1))\par
\b\f3 Dequeue: \b0\f2 Remove element from front (O(1))\par
\b\f3 Peek: \b0\f2 View front element (O(1))\par
\b\f3 Time Complexity: \b0\f2 O(1) for all operations.\par
\b\f3 Space Complexity: \b0\f2 O(n)\par
\b\f0 Sample Code:\par
\b0\f2 #define MAX 100\par
int queue[MAX], front = -1, rear = -1;\par
void enqueue(int x) \{ queue[++rear] = x; if (front == -1) front = 0; \}\par
int dequeue() \{ int x = queue[front]; if (front == rear) front = rear = -1; else front++; return x; \}\par
int peek() \{ return queue[front]; \}\par
\b\f3 Applications: \b0\f2 Process scheduling, buffering.\par
\b\f3 Advantages: \b0\f2 Simple to implement, efficient for FIFO operations.\par
\b\f3 Disadvantages: \b0\f2 Fixed size (array implementation), less flexible than linked list-based implementation.\par
\b\f0 5.Binary Trees\par
Definition: \b0\f2 A hierarchical data structure in which each node has at most two children.\par
\b\f0 Operations:\b0\f2\par
\b\f3 Insertion: \b0\f2 Add node (O(n))\par
\b\f3 Deletion: \b0\f2 Remove node (O(n))\par
\b\f3 Search: \b0\f2 Find node (O(n))\par
\b\f3 Traversal: \b0\f2 Visit nodes (O(n))\par
\b\f3 Time Complexity: \b0\f2 O(n) for insertion, deletion, search, and traversal.\par
\b\f3 Space Complexity: \b0\f2 O(n)\par
\b\f0 Sample Code:\b0\f2\par
struct Node \{\par
    int data;\par
    struct Node* left;\par
    struct Node* right;\par
\};\par
struct Node* newNode(int data) \{\par
    struct Node* node = (struct Node*)malloc(sizeof(struct Node));\par
    node->data = data;\par
    node->left = node->right = NULL;\par
    return node;\par
\}\par
\b\f3 Applications: \b0\f2 Hierarchical data representation, parsing expressions.\par
\b\f3 Advantages: \b0\f2 Flexible size, straightforward traversal algorithms.\par
\b\f3 Disadvantages: \b0\f2 Can become unbalanced, leading to poor performance.\par
\b\f0 6.Binary Search Trees (BST)\b0\f2\par
\b\f0 Definition: \b0\f2 A binary tree where each node has a key greater than all the keys in the left subtree and less than those in the right subtree.\par
\b\f0 Operations:\b0\f2\par
\b\f3 Insertion: \b0\f2 Add node (O(log n) avg)\par
\b\f3 Deletion: \b0\f2 Remove node (O(log n) avg)\par
\b\f3 Search: \b0\f2 Find node (O(log n) avg)\par
\b\f3 Time Complexity: \b0\f2 O(log n) avg, O(n) worst case.\par
\b\f3 Space Complexity: \b0\f2 O(n)\par
\b\f0 Sample Code:\b0\f2\par
struct Node \{\par
    int data;\par
    struct Node* left;\par
    struct Node* right;\par
\};\par
struct Node* insert(struct Node* node, int data) \{\par
    if (node == NULL) return newNode(data);\par
    if (data < node->data) node->left = insert(node->left, data);\par
    else node->right = insert(node->right, data);\par
    return node;\par
\}\par
\b\f3 Applications: \b0\f2 Efficient searching and sorting operations.\par
\b\f3 Advantages: \b0\f2 Efficient searching, dynamic size.\par
\b\f3 Disadvantages: \b0\f2 Can become unbalanced, leading to O(n) operations.\par
\b\f0 7.AVL Trees\par
Definition: \b0\f2 A self-balancing binary search tree where the height of the left and right subtrees of every node differ by at most one.\par
\b\f0 Operations:\b0\f2\par
\b\f3 Insertion: \b0\f2 Add node (O(log n))\par
\b\f3 Deletion: \b0\f2 Remove node (O(log n))\par
\b\f3 Search: \b0\f2 Find node (O(log n))\par
\b\f3 Time Complexity: \b0\f2 O(log n) for all operations.\par
\b\f3 Space Complexity: \b0\f2 O(n)\par
\b\f0 Sample Code:\b0\f2\par
struct Node \{\par
    int data;\par
    struct Node* left;\par
    struct Node* right;\par
    int height;\par
\};\par
int height(struct Node* n) \{ return n ? n->height : 0; \}\par
struct Node* rightRotate(struct Node* y) \{\par
    struct Node* x = y->left;\par
    struct Node* T2 = x->right;\par
    x->right = y;\par
    y->left = T2;\par
    y->height = max(height(y->left), height(y->right)) + 1;\par
    x->height = max(height(x->left), height(x->right)) + 1;\par
    return x;\par
\}\par
// Similar leftRotate and balance functions needed\par
\b\f3 Applications: \b0\f2 Databases, file systems where frequent insertions and deletions occur.\par
\b\f3 Advantages: \b0\f2 Always balanced, guaranteed O(log n) operations.\par
\b\f3 Disadvantages: \b0\f2 More complex rotations, higher constant factors due to balancing overhead.\par
\b\f0 8.Graphs\b0\f2\par
\b\f0 Definition: \b0\f2 A set of vertices connected by edges.\par
\b\f0 Operations:\par
\f3 Add Edge: \b0\f2 Connect vertices (O(1) for adjacency list)\par
\b\f3 Remove Edge: \b0\f2 Disconnect vertices (O(1) for adjacency list)\par
\b\f3 Search: \b0\f2 BFS/DFS (O(V + E))\par
\b\f0 Time Complexity:\b0\f2\par
\b\f3 Add/Remove Edge: \b0\f2 O(1) for adjacency list\par
\b\f3 Search: \b0\f2 O(V + E)\par
\b\f3 Space Complexity:\b0\f2\par
\b\f3 Adjacency List: \b0\f2 O(V + E)\par
\b\f3 Adjacency Matrix: \b0\f2 O(V^2)\par
\b\f0 Sample Code:\b0\f2\par
struct Graph \{\par
    int V;\par
    struct Node* adjList[];\par
\};\par
void addEdge(struct Graph* graph, int src, int dest) \{\par
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\par
    newNode->dest = dest;\par
    newNode->next = graph->adjList[src];\par
    graph->adjList[src] = newNode;\par
\}\par
\b\f3 Applications: \b0\f2 Network routing, social networks, pathfinding algorithms.\par
\b\f3 Advantages: \b0\f2 Flexible representation, suitable for complex relationships.\par
\b\f3 Disadvantages: \b0\f2 Can be complex to implement and manage.\b\f0\par
9.Hashing\par
Definition\b0\f2 : A technique to map keys to values using a hash function.\par
\b\f0 Operations:\b0\f2\par
\b\f3 Insert: \b0\f2 Add key-value pair (O(1) avg)\par
\b\f3 Delete: \b0\f2 Remove key-value pair (O(1) avg)\par
\b\f3 Search: \b0\f2 Find value by key (O(1) avg)\par
\b\f3 Time Complexity: \b0\f2 O(1) average for all operations.\par
\b\f3 Space Complexity: \b0\f2 O(n)\par
\b\f0 Sample Code:\b0\f2\par
#define TABLE_SIZE 100\par
struct Node \{\par
    int key;\par
    int value;\par
    struct Node* next;\par
\};\par
struct Node* hashTable[TABLE_SIZE];\par
int hashFunction(int key) \{ return key % TABLE_SIZE; \}\par
void insert(int key, int value) \{\par
    int hashIndex = hashFunction(key);\par
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\par
    newNode->key = key;\par
    newNode->value = value;\par
    newNode->next = hashTable[hashIndex];\par
    hashTable[hashIndex] = newNode;\par
\}\par
\b\f3 Applications: \b0\f2 Efficient data retrieval, databases, caching.\par
\b\f4 Advantages: \b0\f2 Fast data retrieval.\par
\b\f4 Disadvantages: \b0\f2 Hash collisions, poor performance with bad hash functions or high load factors.\par
}
 